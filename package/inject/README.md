# Dependency injection for Dart and Flutter

`package:inject` is a dependency injection framework for Dart and Flutter apps.
The framework favors simplicity and idiomaticity over feature richness.

## What is the difference between DI and DI framework?

_Dependency injection_ is a programming pattern that encourages separation of
two concerns:

1. Dependency - one object uses another object
2. Provider - the method used to provide a reference to another object

A dependency injection _framework_ reduces the boilerplate associated with
wiring up dependencies with providers.

## How does `package:inject` work?

`package:inject` reads annotations in your Dart code, then generates a class,
known as _injector_, that encapsulates all the "wiring" logic that connects
dependencies with the corresponding providers.

The injector can be used as a bootstrapping mechanism whereby a root object is
instantiated along with all its dependencies wired up. From that point on, your
program's objects are exercised normally through their API surfaces.

Another way to use the injector class is by treating it as a "service locator"
whereby multiple services can be acquired from it at various points in time. In
this mode the injector object will be issued to the application code, e.g. via a
static getter, or as an [InheritedWidget][1].

[1]: https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html

## Design principles:

If you are interested in contributing to `package:inject`, please keep in mind
the following framework design principles we use:

- You don't need `package:inject`:
  - This is simply a reminder to contributors that Dart is already a highly
    productive general purpose Turing complete language, and you can already
    express everything by just writing the code by hand.
  - A package that uses `package:inject` does not require its downstream
    dependents to use `package:inject`. For example, this is why "injectors" in
    `package:inject` are plain Dart classes (essentially, they are service
    locators) that can be instantiated manually with no exposure to
    `package:inject`.
- All dependency and provider resolution happens at build time. There should
  be no runtime exceptions associated with wiring up dependencies with
  providers. When an error happens during resolution the framework should
  provide a clear actionable error message.
- Generated code is idiomatic Dart:
  - You can navigate, step through, and understand stack traces from the code
    generated by `package:inject`.
  - You can stop using `package:inject` by generating code, then copying it into
    your source tree and maintaining it by hand from then on. This is partially
    why `package:inject` does not have a runtime library. Our entire API is just
    a collection of annotations. This is also why generated code avoids using
    generated identifiers, favoring identifiers derived from user-written names.
    Generated code should also pass the Dart style guide (go/effective-dart) as
    much as possible.
- Keep it simple:
  - `package:inject` features compose well with plain Dart. For example, the
    injector is a plain class that can be instantiated whenever it is
    appropriate and used naturally according to its public API surface.
  - The framework does not "take over" the execution of your programs. You can
    use it in a small part of your program and keep it as an implementation
    detail. The framework does not "leak", does not have side-effects, and does
    not require downstream dependencies to use it.
  - The framework does not require any other frameworks (for example, it does
    not require Flutter or AngularDart). It only uses the core `dart:*`
    libraries that come with all Dart distributions.
